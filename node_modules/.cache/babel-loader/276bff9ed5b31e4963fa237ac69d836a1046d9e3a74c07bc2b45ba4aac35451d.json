{"ast":null,"code":"import axios from 'axios';\nimport JSZip from 'jszip';\nimport { saveAs } from 'file-saver';\nimport PDFMerger from 'pdf-merger-js';\nclass FileMergerService {\n  async mergeFiles(files, mergeType, onProgress) {\n    try {\n      onProgress({\n        percentage: 0,\n        message: 'Starting file processing...'\n      });\n\n      // Download files first if they are URLs\n      const downloadedFiles = await this.downloadFiles(files, onProgress);\n      onProgress({\n        percentage: 50,\n        message: 'Merging files...'\n      });\n\n      // Merge based on type\n      let mergedBlob;\n      let fileName;\n      switch (mergeType) {\n        case 'pdf':\n          const result = await this.mergePDFs(downloadedFiles);\n          mergedBlob = result.blob;\n          fileName = result.fileName;\n          break;\n        case 'zip':\n          const zipResult = await this.mergeAsZip(downloadedFiles);\n          mergedBlob = zipResult.blob;\n          fileName = zipResult.fileName;\n          break;\n        case 'csv':\n          const csvResult = await this.mergeCSVs(downloadedFiles);\n          mergedBlob = csvResult.blob;\n          fileName = csvResult.fileName;\n          break;\n        case 'text':\n          const textResult = await this.mergeTextFiles(downloadedFiles);\n          mergedBlob = textResult.blob;\n          fileName = textResult.fileName;\n          break;\n        default:\n          throw new Error(`Unsupported merge type: ${mergeType}`);\n      }\n      onProgress({\n        percentage: 90,\n        message: 'Preparing download...'\n      });\n\n      // Save the merged file\n      saveAs(mergedBlob, fileName);\n      onProgress({\n        percentage: 100,\n        message: 'Download started!'\n      });\n      return {\n        success: true\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n  async downloadFiles(files, onProgress) {\n    const downloadedFiles = [];\n    const totalFiles = files.length;\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      const progressPercentage = Math.round(i / totalFiles * 40); // 0-40% for downloads\n\n      onProgress({\n        percentage: progressPercentage,\n        message: `Downloading ${file.name}...`\n      });\n      if (file.type === 'url' && file.url) {\n        try {\n          const response = await axios.get(file.url, {\n            responseType: 'arraybuffer',\n            timeout: 30000,\n            // 30 second timeout\n            headers: {\n              'Accept': '*/*'\n            }\n          });\n          downloadedFiles.push({\n            name: file.name,\n            data: response.data\n          });\n        } catch (error) {\n          throw new Error(`Failed to download ${file.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n      } else if (file.type === 'upload' && file.file) {\n        const arrayBuffer = await file.file.arrayBuffer();\n        downloadedFiles.push({\n          name: file.name,\n          data: arrayBuffer,\n          file: file.file\n        });\n      }\n    }\n    return downloadedFiles;\n  }\n  async mergePDFs(files) {\n    const merger = new PDFMerger();\n    for (const file of files) {\n      if (file.data instanceof ArrayBuffer) {\n        await merger.add(new Uint8Array(file.data));\n      } else if (file.file) {\n        // Convert File to ArrayBuffer first\n        const fileArrayBuffer = await file.file.arrayBuffer();\n        await merger.add(new Uint8Array(fileArrayBuffer));\n      }\n    }\n    const mergedPdfBuffer = await merger.saveAsBuffer();\n    const blob = new Blob([mergedPdfBuffer], {\n      type: 'application/pdf'\n    });\n    return {\n      blob,\n      fileName: `merged-${Date.now()}.pdf`\n    };\n  }\n  async mergeAsZip(files) {\n    const zip = new JSZip();\n    for (const file of files) {\n      if (file.data instanceof ArrayBuffer) {\n        zip.file(file.name, file.data);\n      } else if (typeof file.data === 'string') {\n        zip.file(file.name, file.data);\n      }\n    }\n    const zipBlob = await zip.generateAsync({\n      type: 'blob'\n    });\n    return {\n      blob: zipBlob,\n      fileName: `merged-files-${Date.now()}.zip`\n    };\n  }\n  async mergeCSVs(files) {\n    let mergedContent = '';\n    let headerAdded = false;\n    for (const file of files) {\n      let content;\n      if (file.data instanceof ArrayBuffer) {\n        content = new TextDecoder().decode(file.data);\n      } else {\n        content = file.data;\n      }\n      const lines = content.split('\\n').filter(line => line.trim());\n      if (lines.length === 0) continue;\n      if (!headerAdded) {\n        // Add header from first file\n        mergedContent += lines[0] + '\\n';\n        headerAdded = true;\n        // Add data rows from first file\n        mergedContent += lines.slice(1).join('\\n') + '\\n';\n      } else {\n        // Skip header, add only data rows from subsequent files\n        mergedContent += lines.slice(1).join('\\n') + '\\n';\n      }\n    }\n    const blob = new Blob([mergedContent.trim()], {\n      type: 'text/csv'\n    });\n    return {\n      blob,\n      fileName: `merged-data-${Date.now()}.csv`\n    };\n  }\n  async mergeTextFiles(files) {\n    let mergedContent = '';\n    for (const file of files) {\n      let content;\n      if (file.data instanceof ArrayBuffer) {\n        content = new TextDecoder().decode(file.data);\n      } else {\n        content = file.data;\n      }\n      mergedContent += `\\n\\n=== ${file.name} ===\\n\\n`;\n      mergedContent += content;\n    }\n    const blob = new Blob([mergedContent.trim()], {\n      type: 'text/plain'\n    });\n    return {\n      blob,\n      fileName: `merged-text-${Date.now()}.txt`\n    };\n  }\n\n  // Utility method to validate file type\n  validateFileType(fileName, expectedType) {\n    var _fileName$split$pop;\n    const extension = ((_fileName$split$pop = fileName.split('.').pop()) === null || _fileName$split$pop === void 0 ? void 0 : _fileName$split$pop.toLowerCase()) || '';\n    switch (expectedType) {\n      case 'pdf':\n        return extension === 'pdf';\n      case 'zip':\n        return ['zip', 'rar', '7z'].includes(extension);\n      case 'csv':\n        return extension === 'csv';\n      case 'text':\n        return ['txt', 'md', 'text'].includes(extension);\n      default:\n        return false;\n    }\n  }\n}\nexport const fileMergerService = new FileMergerService();","map":{"version":3,"names":["axios","JSZip","saveAs","PDFMerger","FileMergerService","mergeFiles","files","mergeType","onProgress","percentage","message","downloadedFiles","downloadFiles","mergedBlob","fileName","result","mergePDFs","blob","zipResult","mergeAsZip","csvResult","mergeCSVs","textResult","mergeTextFiles","Error","success","error","errorMessage","totalFiles","length","i","file","progressPercentage","Math","round","name","type","url","response","get","responseType","timeout","headers","push","data","arrayBuffer","merger","ArrayBuffer","add","Uint8Array","fileArrayBuffer","mergedPdfBuffer","saveAsBuffer","Blob","Date","now","zip","zipBlob","generateAsync","mergedContent","headerAdded","content","TextDecoder","decode","lines","split","filter","line","trim","slice","join","validateFileType","expectedType","_fileName$split$pop","extension","pop","toLowerCase","includes","fileMergerService"],"sources":["/Users/anurag.shahi/workstation/swiggy-repos/ads/pdf merger./src/services/fileMergerService.ts"],"sourcesContent":["import axios from 'axios';\nimport JSZip from 'jszip';\nimport { saveAs } from 'file-saver';\nimport PDFMerger from 'pdf-merger-js';\nimport { FileItem, MergeType, ProgressData } from '../App';\n\ninterface MergeResult {\n  success: boolean;\n  error?: string;\n}\n\nclass FileMergerService {\n  async mergeFiles(\n    files: FileItem[], \n    mergeType: MergeType, \n    onProgress: (progress: ProgressData) => void\n  ): Promise<MergeResult> {\n    try {\n      onProgress({ percentage: 0, message: 'Starting file processing...' });\n\n      // Download files first if they are URLs\n      const downloadedFiles = await this.downloadFiles(files, onProgress);\n      \n      onProgress({ percentage: 50, message: 'Merging files...' });\n\n      // Merge based on type\n      let mergedBlob: Blob;\n      let fileName: string;\n\n      switch (mergeType) {\n        case 'pdf':\n          const result = await this.mergePDFs(downloadedFiles);\n          mergedBlob = result.blob;\n          fileName = result.fileName;\n          break;\n        case 'zip':\n          const zipResult = await this.mergeAsZip(downloadedFiles);\n          mergedBlob = zipResult.blob;\n          fileName = zipResult.fileName;\n          break;\n        case 'csv':\n          const csvResult = await this.mergeCSVs(downloadedFiles);\n          mergedBlob = csvResult.blob;\n          fileName = csvResult.fileName;\n          break;\n        case 'text':\n          const textResult = await this.mergeTextFiles(downloadedFiles);\n          mergedBlob = textResult.blob;\n          fileName = textResult.fileName;\n          break;\n        default:\n          throw new Error(`Unsupported merge type: ${mergeType}`);\n      }\n\n      onProgress({ percentage: 90, message: 'Preparing download...' });\n\n      // Save the merged file\n      saveAs(mergedBlob, fileName);\n\n      onProgress({ percentage: 100, message: 'Download started!' });\n\n      return { success: true };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  private async downloadFiles(\n    files: FileItem[], \n    onProgress: (progress: ProgressData) => void\n  ): Promise<Array<{ name: string; data: ArrayBuffer | string; file?: File }>> {\n    const downloadedFiles: Array<{ name: string; data: ArrayBuffer | string; file?: File }> = [];\n    const totalFiles = files.length;\n\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      const progressPercentage = Math.round((i / totalFiles) * 40); // 0-40% for downloads\n      \n      onProgress({ \n        percentage: progressPercentage, \n        message: `Downloading ${file.name}...` \n      });\n\n      if (file.type === 'url' && file.url) {\n        try {\n          const response = await axios.get(file.url, {\n            responseType: 'arraybuffer',\n            timeout: 30000, // 30 second timeout\n            headers: {\n              'Accept': '*/*',\n            }\n          });\n          downloadedFiles.push({\n            name: file.name,\n            data: response.data\n          });\n        } catch (error) {\n          throw new Error(`Failed to download ${file.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n      } else if (file.type === 'upload' && file.file) {\n        const arrayBuffer = await file.file.arrayBuffer();\n        downloadedFiles.push({\n          name: file.name,\n          data: arrayBuffer,\n          file: file.file\n        });\n      }\n    }\n\n    return downloadedFiles;\n  }\n\n  private async mergePDFs(files: Array<{ name: string; data: ArrayBuffer | string; file?: File }>): Promise<{ blob: Blob; fileName: string }> {\n    const merger = new PDFMerger();\n\n    for (const file of files) {\n      if (file.data instanceof ArrayBuffer) {\n        await merger.add(new Uint8Array(file.data));\n      } else if (file.file) {\n        // Convert File to ArrayBuffer first\n        const fileArrayBuffer = await file.file.arrayBuffer();\n        await merger.add(new Uint8Array(fileArrayBuffer));\n      }\n    }\n\n    const mergedPdfBuffer = await merger.saveAsBuffer();\n    const blob = new Blob([mergedPdfBuffer], { type: 'application/pdf' });\n    \n    return {\n      blob,\n      fileName: `merged-${Date.now()}.pdf`\n    };\n  }\n\n  private async mergeAsZip(files: Array<{ name: string; data: ArrayBuffer | string; file?: File }>): Promise<{ blob: Blob; fileName: string }> {\n    const zip = new JSZip();\n\n    for (const file of files) {\n      if (file.data instanceof ArrayBuffer) {\n        zip.file(file.name, file.data);\n      } else if (typeof file.data === 'string') {\n        zip.file(file.name, file.data);\n      }\n    }\n\n    const zipBlob = await zip.generateAsync({ type: 'blob' });\n    \n    return {\n      blob: zipBlob,\n      fileName: `merged-files-${Date.now()}.zip`\n    };\n  }\n\n  private async mergeCSVs(files: Array<{ name: string; data: ArrayBuffer | string; file?: File }>): Promise<{ blob: Blob; fileName: string }> {\n    let mergedContent = '';\n    let headerAdded = false;\n\n    for (const file of files) {\n      let content: string;\n      \n      if (file.data instanceof ArrayBuffer) {\n        content = new TextDecoder().decode(file.data);\n      } else {\n        content = file.data as string;\n      }\n\n      const lines = content.split('\\n').filter(line => line.trim());\n      \n      if (lines.length === 0) continue;\n\n      if (!headerAdded) {\n        // Add header from first file\n        mergedContent += lines[0] + '\\n';\n        headerAdded = true;\n        // Add data rows from first file\n        mergedContent += lines.slice(1).join('\\n') + '\\n';\n      } else {\n        // Skip header, add only data rows from subsequent files\n        mergedContent += lines.slice(1).join('\\n') + '\\n';\n      }\n    }\n\n    const blob = new Blob([mergedContent.trim()], { type: 'text/csv' });\n    \n    return {\n      blob,\n      fileName: `merged-data-${Date.now()}.csv`\n    };\n  }\n\n  private async mergeTextFiles(files: Array<{ name: string; data: ArrayBuffer | string; file?: File }>): Promise<{ blob: Blob; fileName: string }> {\n    let mergedContent = '';\n\n    for (const file of files) {\n      let content: string;\n      \n      if (file.data instanceof ArrayBuffer) {\n        content = new TextDecoder().decode(file.data);\n      } else {\n        content = file.data as string;\n      }\n\n      mergedContent += `\\n\\n=== ${file.name} ===\\n\\n`;\n      mergedContent += content;\n    }\n\n    const blob = new Blob([mergedContent.trim()], { type: 'text/plain' });\n    \n    return {\n      blob,\n      fileName: `merged-text-${Date.now()}.txt`\n    };\n  }\n\n  // Utility method to validate file type\n  validateFileType(fileName: string, expectedType: MergeType): boolean {\n    const extension = fileName.split('.').pop()?.toLowerCase() || '';\n    \n    switch (expectedType) {\n      case 'pdf':\n        return extension === 'pdf';\n      case 'zip':\n        return ['zip', 'rar', '7z'].includes(extension);\n      case 'csv':\n        return extension === 'csv';\n      case 'text':\n        return ['txt', 'md', 'text'].includes(extension);\n      default:\n        return false;\n    }\n  }\n}\n\nexport const fileMergerService = new FileMergerService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}