{"ast":null,"code":"const {\n  PDFDocument\n} = require('pdf-lib');\nconst globalObject = typeof globalThis === 'object' ? globalThis : typeof window === 'object' ? window // Browser\n: typeof self === 'object' ? self // Worker\n: this;\nclass PDFMerger {\n  constructor() {\n    this.reset();\n    this.loadOptions = {\n      // allow merging of encrypted pdfs (issue #88)\n      ignoreEncryption: true\n    };\n  }\n  reset() {\n    this.doc = undefined;\n  }\n  async add(inputFile, pages) {\n    await this._ensureDoc();\n    if (typeof pages === 'undefined' || pages === null) {\n      await this._addEntireDocument(inputFile);\n    } else if (Array.isArray(pages)) {\n      await this._addGivenPages(inputFile, pages);\n    } else if (pages.indexOf(',') > 0) {\n      const aPages = pages.replace(/ /g, '').split(',');\n      await this._addGivenPages(inputFile, aPages);\n    } else if (pages.toLowerCase().indexOf('to') >= 0) {\n      const span = pages.replace(/ /g, '').split('to');\n      const from = parseInt(span[0]);\n      const to = parseInt(span[1]);\n      await this._addFromToPage(inputFile, from, to);\n    } else if (pages.indexOf('-') >= 0) {\n      const span = pages.replace(/ /g, '').split('-');\n      const from = parseInt(span[0]);\n      const to = parseInt(span[1]);\n      await this._addFromToPage(inputFile, from, to);\n    } else {\n      throw new Error('invalid parameter \"pages\"');\n    }\n  }\n  async _ensureDoc() {\n    if (!this.doc) {\n      this.doc = await PDFDocument.create();\n    }\n  }\n  async _getInputAsUint8Array(input) {\n    if (input instanceof Uint8Array) {\n      return input;\n    }\n    if (input instanceof ArrayBuffer || Object.prototype.toString.call(input) === '[object ArrayBuffer]') {\n      return new Uint8Array(input);\n    }\n    if (typeof input === 'string' || input instanceof String) {\n      try {\n        Boolean(new URL(input));\n      } catch (e) {\n        throw new Error(\"This is not a valid url: \".concat(input));\n      }\n      const res = await globalObject.fetch(input);\n      const aBuffer = await res.arrayBuffer();\n      return new Uint8Array(aBuffer);\n    }\n    if (input instanceof globalObject.File) {\n      const fileReader = new globalObject.FileReader();\n      fileReader.onload = function (evt) {\n        return fileReader.result;\n      };\n      fileReader.readAsArrayBuffer(input);\n    }\n    if (input instanceof globalObject.Blob) {\n      const aBuffer = await input.arrayBuffer();\n      return new Uint8Array(aBuffer);\n    }\n    console.log({\n      input,\n      inputc: Object.prototype.toString.call(input),\n      ArrayBuffer,\n      eq: input.contructor !== ArrayBuffer\n    });\n    throw new Error('pdf must be represented as an ArrayBuffer, Blob, File, URL or fetchable string');\n  }\n  async _addEntireDocument(input) {\n    const src = await this._getInputAsUint8Array(input);\n    const srcDoc = await PDFDocument.load(src, this.loadOptions);\n    const copiedPages = await this.doc.copyPages(srcDoc, srcDoc.getPageIndices());\n    copiedPages.forEach(page => {\n      this.doc.addPage(page);\n    });\n  }\n  async _addFromToPage(inputFile, from, to) {\n    if (typeof from !== 'number' || typeof to !== 'number' || from < 0 || from < 0) {\n      throw new Error('Invalid function parameter. \\'from\\' and \\'to\\' must be positive \\'numbers\\'.');\n    }\n    if (to < from) {\n      throw new Error('Invalid function parameter. \\'to\\' must be greater or eaqual to \\'from\\'.');\n    }\n    const src = await this._getInputAsUint8Array(inputFile);\n    const srcDoc = await PDFDocument.load(src, this.loadOptions);\n    const pageCount = srcDoc.getPageCount();\n    if (from >= pageCount || to >= pageCount) {\n      throw new Error(\"Invalid function parameter. The document has not enough pages. (from:\".concat(from, \", to:\").concat(to, \", pages:\").concat(pageCount, \")\"));\n    }\n\n    // create a array [2,3,4] with from=2 and to=4\n    const pages = Array.from({\n      length: to - from + 1\n    }, (_, i) => i + from - 1);\n    const copiedPages = await this.doc.copyPages(srcDoc, pages);\n    copiedPages.forEach(page => {\n      this.doc.addPage(page);\n    });\n  }\n  async _addGivenPages(inputFile, pages) {\n    if (pages.length <= 0) return;\n    const src = await this._getInputAsUint8Array(inputFile);\n    const srcDoc = await PDFDocument.load(src, this.loadOptions);\n    const pagesIndexed1 = pages.map(p => p - 1);\n    const copiedPages = await this.doc.copyPages(srcDoc, pagesIndexed1);\n    copiedPages.forEach(page => {\n      this.doc.addPage(page);\n    });\n  }\n  async setMetadata(metadata) {\n    await this._ensureDoc();\n    if (metadata.producer) this.doc.setProducer(metadata.producer);\n    if (metadata.author) this.doc.setAuthor(metadata.author);\n    if (metadata.title) this.doc.setTitle(metadata.title);\n    if (metadata.creator) this.doc.setCreator(metadata.creator);\n  }\n  async saveAsBuffer() {\n    await this._ensureDoc();\n    return await this.doc.save();\n  }\n  async saveAsBlob() {\n    const buffer = await this.saveAsBuffer();\n    return new globalObject.Blob([buffer], {\n      type: 'application/pdf'\n    });\n  }\n  async save(fileName) {\n    const dataUri = await this.doc.saveAsBase64({\n      dataUri: true\n    });\n    const link = document.createElement('a');\n    link.href = dataUri;\n    link.download = \"\".concat(fileName, \".pdf\");\n    link.click();\n  }\n}\nmodule.exports = PDFMerger;","map":{"version":3,"names":["PDFDocument","require","globalObject","globalThis","window","self","PDFMerger","constructor","reset","loadOptions","ignoreEncryption","doc","undefined","add","inputFile","pages","_ensureDoc","_addEntireDocument","Array","isArray","_addGivenPages","indexOf","aPages","replace","split","toLowerCase","span","from","parseInt","to","_addFromToPage","Error","create","_getInputAsUint8Array","input","Uint8Array","ArrayBuffer","Object","prototype","toString","call","String","Boolean","URL","e","concat","res","fetch","aBuffer","arrayBuffer","File","fileReader","FileReader","onload","evt","result","readAsArrayBuffer","Blob","console","log","inputc","eq","contructor","src","srcDoc","load","copiedPages","copyPages","getPageIndices","forEach","page","addPage","pageCount","getPageCount","length","_","i","pagesIndexed1","map","p","setMetadata","metadata","producer","setProducer","author","setAuthor","title","setTitle","creator","setCreator","saveAsBuffer","save","saveAsBlob","buffer","type","fileName","dataUri","saveAsBase64","link","document","createElement","href","download","click","module","exports"],"sources":["/Users/anurag.shahi/workstation/swiggy-repos/ads/pdf merger./node_modules/pdf-merger-js/browser.js"],"sourcesContent":["const { PDFDocument } = require('pdf-lib')\n\nconst globalObject =\n  typeof globalThis === 'object'\n    ? globalThis\n    : typeof window === 'object'\n      ? window // Browser\n      : typeof self === 'object'\n        ? self // Worker\n        : this\n\nclass PDFMerger {\n  constructor () {\n    this.reset()\n\n    this.loadOptions = {\n      // allow merging of encrypted pdfs (issue #88)\n      ignoreEncryption: true\n    }\n  }\n\n  reset () {\n    this.doc = undefined\n  }\n\n  async add (inputFile, pages) {\n    await this._ensureDoc()\n    if (typeof pages === 'undefined' || pages === null) {\n      await this._addEntireDocument(inputFile)\n    } else if (Array.isArray(pages)) {\n      await this._addGivenPages(inputFile, pages)\n    } else if (pages.indexOf(',') > 0) {\n      const aPages = pages.replace(/ /g, '').split(',')\n      await this._addGivenPages(inputFile, aPages)\n    } else if (pages.toLowerCase().indexOf('to') >= 0) {\n      const span = pages.replace(/ /g, '').split('to')\n      const from = parseInt(span[0])\n      const to = parseInt(span[1])\n      await this._addFromToPage(inputFile, from, to)\n    } else if (pages.indexOf('-') >= 0) {\n      const span = pages.replace(/ /g, '').split('-')\n      const from = parseInt(span[0])\n      const to = parseInt(span[1])\n      await this._addFromToPage(inputFile, from, to)\n    } else {\n      throw new Error('invalid parameter \"pages\"')\n    }\n  }\n\n  async _ensureDoc () {\n    if (!this.doc) {\n      this.doc = await PDFDocument.create()\n    }\n  }\n\n  async _getInputAsUint8Array (input) {\n    if (input instanceof Uint8Array) {\n      return input\n    }\n\n    if (input instanceof ArrayBuffer || Object.prototype.toString.call(input) === '[object ArrayBuffer]') {\n      return new Uint8Array(input)\n    }\n\n    if (typeof input === 'string' || input instanceof String) {\n      try {\n        Boolean(new URL(input))\n      } catch (e) {\n        throw new Error(`This is not a valid url: ${input}`)\n      }\n      const res = await globalObject.fetch(input)\n      const aBuffer = await res.arrayBuffer()\n      return new Uint8Array(aBuffer)\n    }\n\n    if (input instanceof globalObject.File) {\n      const fileReader = new globalObject.FileReader()\n      fileReader.onload = function (evt) {\n        return fileReader.result\n      }\n      fileReader.readAsArrayBuffer(input)\n    }\n\n    if (input instanceof globalObject.Blob) {\n      const aBuffer = await input.arrayBuffer()\n      return new Uint8Array(aBuffer)\n    }\n\n    console.log({ input, inputc: Object.prototype.toString.call(input), ArrayBuffer, eq: input.contructor !== ArrayBuffer })\n    throw new Error('pdf must be represented as an ArrayBuffer, Blob, File, URL or fetchable string')\n  }\n\n  async _addEntireDocument (input) {\n    const src = await this._getInputAsUint8Array(input)\n    const srcDoc = await PDFDocument.load(src, this.loadOptions)\n\n    const copiedPages = await this.doc.copyPages(srcDoc, srcDoc.getPageIndices())\n    copiedPages.forEach((page) => {\n      this.doc.addPage(page)\n    })\n  }\n\n  async _addFromToPage (inputFile, from, to) {\n    if (typeof from !== 'number' || typeof to !== 'number' || from < 0 || from < 0) {\n      throw new Error('Invalid function parameter. \\'from\\' and \\'to\\' must be positive \\'numbers\\'.')\n    }\n    if (to < from) {\n      throw new Error('Invalid function parameter. \\'to\\' must be greater or eaqual to \\'from\\'.')\n    }\n\n    const src = await this._getInputAsUint8Array(inputFile)\n    const srcDoc = await PDFDocument.load(src, this.loadOptions)\n    const pageCount = srcDoc.getPageCount()\n\n    if (from >= pageCount || to >= pageCount) {\n      throw new Error(`Invalid function parameter. The document has not enough pages. (from:${from}, to:${to}, pages:${pageCount})`)\n    }\n\n    // create a array [2,3,4] with from=2 and to=4\n    const pages = Array.from({ length: (to - from) + 1 }, (_, i) => i + from - 1)\n    const copiedPages = await this.doc.copyPages(srcDoc, pages)\n    copiedPages.forEach((page) => {\n      this.doc.addPage(page)\n    })\n  }\n\n  async _addGivenPages (inputFile, pages) {\n    if (pages.length <= 0) return\n\n    const src = await this._getInputAsUint8Array(inputFile)\n    const srcDoc = await PDFDocument.load(src, this.loadOptions)\n\n    const pagesIndexed1 = pages.map(p => p - 1)\n    const copiedPages = await this.doc.copyPages(srcDoc, pagesIndexed1)\n    copiedPages.forEach((page) => {\n      this.doc.addPage(page)\n    })\n  }\n\n  async setMetadata (metadata) {\n    await this._ensureDoc()\n    if (metadata.producer) this.doc.setProducer(metadata.producer)\n    if (metadata.author) this.doc.setAuthor(metadata.author)\n    if (metadata.title) this.doc.setTitle(metadata.title)\n    if (metadata.creator) this.doc.setCreator(metadata.creator)\n  }\n\n  async saveAsBuffer () {\n    await this._ensureDoc()\n    return await this.doc.save()\n  }\n\n  async saveAsBlob () {\n    const buffer = await this.saveAsBuffer()\n\n    return new globalObject.Blob([buffer], {\n      type: 'application/pdf'\n    })\n  }\n\n  async save (fileName) {\n    const dataUri = await this.doc.saveAsBase64({ dataUri: true })\n\n    const link = document.createElement('a')\n    link.href = dataUri\n    link.download = `${fileName}.pdf`\n    link.click()\n  }\n}\n\nmodule.exports = PDFMerger\n"],"mappings":"AAAA,MAAM;EAAEA;AAAY,CAAC,GAAGC,OAAO,CAAC,SAAS,CAAC;AAE1C,MAAMC,YAAY,GAChB,OAAOC,UAAU,KAAK,QAAQ,GAC1BA,UAAU,GACV,OAAOC,MAAM,KAAK,QAAQ,GACxBA,MAAM,CAAC;AAAA,EACP,OAAOC,IAAI,KAAK,QAAQ,GACtBA,IAAI,CAAC;AAAA,EACL,IAAI;AAEd,MAAMC,SAAS,CAAC;EACdC,WAAWA,CAAA,EAAI;IACb,IAAI,CAACC,KAAK,CAAC,CAAC;IAEZ,IAAI,CAACC,WAAW,GAAG;MACjB;MACAC,gBAAgB,EAAE;IACpB,CAAC;EACH;EAEAF,KAAKA,CAAA,EAAI;IACP,IAAI,CAACG,GAAG,GAAGC,SAAS;EACtB;EAEA,MAAMC,GAAGA,CAAEC,SAAS,EAAEC,KAAK,EAAE;IAC3B,MAAM,IAAI,CAACC,UAAU,CAAC,CAAC;IACvB,IAAI,OAAOD,KAAK,KAAK,WAAW,IAAIA,KAAK,KAAK,IAAI,EAAE;MAClD,MAAM,IAAI,CAACE,kBAAkB,CAACH,SAAS,CAAC;IAC1C,CAAC,MAAM,IAAII,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,EAAE;MAC/B,MAAM,IAAI,CAACK,cAAc,CAACN,SAAS,EAAEC,KAAK,CAAC;IAC7C,CAAC,MAAM,IAAIA,KAAK,CAACM,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;MACjC,MAAMC,MAAM,GAAGP,KAAK,CAACQ,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC;MACjD,MAAM,IAAI,CAACJ,cAAc,CAACN,SAAS,EAAEQ,MAAM,CAAC;IAC9C,CAAC,MAAM,IAAIP,KAAK,CAACU,WAAW,CAAC,CAAC,CAACJ,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;MACjD,MAAMK,IAAI,GAAGX,KAAK,CAACQ,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAACC,KAAK,CAAC,IAAI,CAAC;MAChD,MAAMG,IAAI,GAAGC,QAAQ,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC;MAC9B,MAAMG,EAAE,GAAGD,QAAQ,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC;MAC5B,MAAM,IAAI,CAACI,cAAc,CAAChB,SAAS,EAAEa,IAAI,EAAEE,EAAE,CAAC;IAChD,CAAC,MAAM,IAAId,KAAK,CAACM,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;MAClC,MAAMK,IAAI,GAAGX,KAAK,CAACQ,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC;MAC/C,MAAMG,IAAI,GAAGC,QAAQ,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC;MAC9B,MAAMG,EAAE,GAAGD,QAAQ,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC;MAC5B,MAAM,IAAI,CAACI,cAAc,CAAChB,SAAS,EAAEa,IAAI,EAAEE,EAAE,CAAC;IAChD,CAAC,MAAM;MACL,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;IAC9C;EACF;EAEA,MAAMf,UAAUA,CAAA,EAAI;IAClB,IAAI,CAAC,IAAI,CAACL,GAAG,EAAE;MACb,IAAI,CAACA,GAAG,GAAG,MAAMX,WAAW,CAACgC,MAAM,CAAC,CAAC;IACvC;EACF;EAEA,MAAMC,qBAAqBA,CAAEC,KAAK,EAAE;IAClC,IAAIA,KAAK,YAAYC,UAAU,EAAE;MAC/B,OAAOD,KAAK;IACd;IAEA,IAAIA,KAAK,YAAYE,WAAW,IAAIC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACN,KAAK,CAAC,KAAK,sBAAsB,EAAE;MACpG,OAAO,IAAIC,UAAU,CAACD,KAAK,CAAC;IAC9B;IAEA,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,YAAYO,MAAM,EAAE;MACxD,IAAI;QACFC,OAAO,CAAC,IAAIC,GAAG,CAACT,KAAK,CAAC,CAAC;MACzB,CAAC,CAAC,OAAOU,CAAC,EAAE;QACV,MAAM,IAAIb,KAAK,6BAAAc,MAAA,CAA6BX,KAAK,CAAE,CAAC;MACtD;MACA,MAAMY,GAAG,GAAG,MAAM5C,YAAY,CAAC6C,KAAK,CAACb,KAAK,CAAC;MAC3C,MAAMc,OAAO,GAAG,MAAMF,GAAG,CAACG,WAAW,CAAC,CAAC;MACvC,OAAO,IAAId,UAAU,CAACa,OAAO,CAAC;IAChC;IAEA,IAAId,KAAK,YAAYhC,YAAY,CAACgD,IAAI,EAAE;MACtC,MAAMC,UAAU,GAAG,IAAIjD,YAAY,CAACkD,UAAU,CAAC,CAAC;MAChDD,UAAU,CAACE,MAAM,GAAG,UAAUC,GAAG,EAAE;QACjC,OAAOH,UAAU,CAACI,MAAM;MAC1B,CAAC;MACDJ,UAAU,CAACK,iBAAiB,CAACtB,KAAK,CAAC;IACrC;IAEA,IAAIA,KAAK,YAAYhC,YAAY,CAACuD,IAAI,EAAE;MACtC,MAAMT,OAAO,GAAG,MAAMd,KAAK,CAACe,WAAW,CAAC,CAAC;MACzC,OAAO,IAAId,UAAU,CAACa,OAAO,CAAC;IAChC;IAEAU,OAAO,CAACC,GAAG,CAAC;MAAEzB,KAAK;MAAE0B,MAAM,EAAEvB,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACN,KAAK,CAAC;MAAEE,WAAW;MAAEyB,EAAE,EAAE3B,KAAK,CAAC4B,UAAU,KAAK1B;IAAY,CAAC,CAAC;IACxH,MAAM,IAAIL,KAAK,CAAC,gFAAgF,CAAC;EACnG;EAEA,MAAMd,kBAAkBA,CAAEiB,KAAK,EAAE;IAC/B,MAAM6B,GAAG,GAAG,MAAM,IAAI,CAAC9B,qBAAqB,CAACC,KAAK,CAAC;IACnD,MAAM8B,MAAM,GAAG,MAAMhE,WAAW,CAACiE,IAAI,CAACF,GAAG,EAAE,IAAI,CAACtD,WAAW,CAAC;IAE5D,MAAMyD,WAAW,GAAG,MAAM,IAAI,CAACvD,GAAG,CAACwD,SAAS,CAACH,MAAM,EAAEA,MAAM,CAACI,cAAc,CAAC,CAAC,CAAC;IAC7EF,WAAW,CAACG,OAAO,CAAEC,IAAI,IAAK;MAC5B,IAAI,CAAC3D,GAAG,CAAC4D,OAAO,CAACD,IAAI,CAAC;IACxB,CAAC,CAAC;EACJ;EAEA,MAAMxC,cAAcA,CAAEhB,SAAS,EAAEa,IAAI,EAAEE,EAAE,EAAE;IACzC,IAAI,OAAOF,IAAI,KAAK,QAAQ,IAAI,OAAOE,EAAE,KAAK,QAAQ,IAAIF,IAAI,GAAG,CAAC,IAAIA,IAAI,GAAG,CAAC,EAAE;MAC9E,MAAM,IAAII,KAAK,CAAC,+EAA+E,CAAC;IAClG;IACA,IAAIF,EAAE,GAAGF,IAAI,EAAE;MACb,MAAM,IAAII,KAAK,CAAC,2EAA2E,CAAC;IAC9F;IAEA,MAAMgC,GAAG,GAAG,MAAM,IAAI,CAAC9B,qBAAqB,CAACnB,SAAS,CAAC;IACvD,MAAMkD,MAAM,GAAG,MAAMhE,WAAW,CAACiE,IAAI,CAACF,GAAG,EAAE,IAAI,CAACtD,WAAW,CAAC;IAC5D,MAAM+D,SAAS,GAAGR,MAAM,CAACS,YAAY,CAAC,CAAC;IAEvC,IAAI9C,IAAI,IAAI6C,SAAS,IAAI3C,EAAE,IAAI2C,SAAS,EAAE;MACxC,MAAM,IAAIzC,KAAK,yEAAAc,MAAA,CAAyElB,IAAI,WAAAkB,MAAA,CAAQhB,EAAE,cAAAgB,MAAA,CAAW2B,SAAS,MAAG,CAAC;IAChI;;IAEA;IACA,MAAMzD,KAAK,GAAGG,KAAK,CAACS,IAAI,CAAC;MAAE+C,MAAM,EAAG7C,EAAE,GAAGF,IAAI,GAAI;IAAE,CAAC,EAAE,CAACgD,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAGjD,IAAI,GAAG,CAAC,CAAC;IAC7E,MAAMuC,WAAW,GAAG,MAAM,IAAI,CAACvD,GAAG,CAACwD,SAAS,CAACH,MAAM,EAAEjD,KAAK,CAAC;IAC3DmD,WAAW,CAACG,OAAO,CAAEC,IAAI,IAAK;MAC5B,IAAI,CAAC3D,GAAG,CAAC4D,OAAO,CAACD,IAAI,CAAC;IACxB,CAAC,CAAC;EACJ;EAEA,MAAMlD,cAAcA,CAAEN,SAAS,EAAEC,KAAK,EAAE;IACtC,IAAIA,KAAK,CAAC2D,MAAM,IAAI,CAAC,EAAE;IAEvB,MAAMX,GAAG,GAAG,MAAM,IAAI,CAAC9B,qBAAqB,CAACnB,SAAS,CAAC;IACvD,MAAMkD,MAAM,GAAG,MAAMhE,WAAW,CAACiE,IAAI,CAACF,GAAG,EAAE,IAAI,CAACtD,WAAW,CAAC;IAE5D,MAAMoE,aAAa,GAAG9D,KAAK,CAAC+D,GAAG,CAACC,CAAC,IAAIA,CAAC,GAAG,CAAC,CAAC;IAC3C,MAAMb,WAAW,GAAG,MAAM,IAAI,CAACvD,GAAG,CAACwD,SAAS,CAACH,MAAM,EAAEa,aAAa,CAAC;IACnEX,WAAW,CAACG,OAAO,CAAEC,IAAI,IAAK;MAC5B,IAAI,CAAC3D,GAAG,CAAC4D,OAAO,CAACD,IAAI,CAAC;IACxB,CAAC,CAAC;EACJ;EAEA,MAAMU,WAAWA,CAAEC,QAAQ,EAAE;IAC3B,MAAM,IAAI,CAACjE,UAAU,CAAC,CAAC;IACvB,IAAIiE,QAAQ,CAACC,QAAQ,EAAE,IAAI,CAACvE,GAAG,CAACwE,WAAW,CAACF,QAAQ,CAACC,QAAQ,CAAC;IAC9D,IAAID,QAAQ,CAACG,MAAM,EAAE,IAAI,CAACzE,GAAG,CAAC0E,SAAS,CAACJ,QAAQ,CAACG,MAAM,CAAC;IACxD,IAAIH,QAAQ,CAACK,KAAK,EAAE,IAAI,CAAC3E,GAAG,CAAC4E,QAAQ,CAACN,QAAQ,CAACK,KAAK,CAAC;IACrD,IAAIL,QAAQ,CAACO,OAAO,EAAE,IAAI,CAAC7E,GAAG,CAAC8E,UAAU,CAACR,QAAQ,CAACO,OAAO,CAAC;EAC7D;EAEA,MAAME,YAAYA,CAAA,EAAI;IACpB,MAAM,IAAI,CAAC1E,UAAU,CAAC,CAAC;IACvB,OAAO,MAAM,IAAI,CAACL,GAAG,CAACgF,IAAI,CAAC,CAAC;EAC9B;EAEA,MAAMC,UAAUA,CAAA,EAAI;IAClB,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACH,YAAY,CAAC,CAAC;IAExC,OAAO,IAAIxF,YAAY,CAACuD,IAAI,CAAC,CAACoC,MAAM,CAAC,EAAE;MACrCC,IAAI,EAAE;IACR,CAAC,CAAC;EACJ;EAEA,MAAMH,IAAIA,CAAEI,QAAQ,EAAE;IACpB,MAAMC,OAAO,GAAG,MAAM,IAAI,CAACrF,GAAG,CAACsF,YAAY,CAAC;MAAED,OAAO,EAAE;IAAK,CAAC,CAAC;IAE9D,MAAME,IAAI,GAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;IACxCF,IAAI,CAACG,IAAI,GAAGL,OAAO;IACnBE,IAAI,CAACI,QAAQ,MAAAzD,MAAA,CAAMkD,QAAQ,SAAM;IACjCG,IAAI,CAACK,KAAK,CAAC,CAAC;EACd;AACF;AAEAC,MAAM,CAACC,OAAO,GAAGnG,SAAS","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}